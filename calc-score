#!/usr/bin/python
import argparse
import os
import sys
import colour

from language import read_truth_file, read_answers_file


def get_roc_trail(answers, truth):
    rmap = {}
    for k, v in answers.items():
        t = truth[k]
        r = rmap.setdefault(v, [0, 0])
        r[0] += t
        r[1] += not t
    return [(score, d[0], d[1])
            for score, d in sorted(rmap.items())]


def calc_roc_from_trail(roc_trail, n_true, n_false):
    true_positives, false_positives = n_true, n_false
    tp_scale = 1.0 / (n_true or 1)
    fp_scale = 1.0 / (n_false or 1)
    px, py = 1, 1  # previous position for area calculation
    auc = 1.0

    for score, positives, negatives in roc_trail:
        false_positives -= negatives
        true_positives -= positives
        x = false_positives * fp_scale
        y = true_positives * tp_scale
        auc += (px + x) * 0.5 * (y - py)
        px = x
        py = y

    auc += px * 0.5 * -py  # is this ever necesssary?
    return auc


def calc_auc(answers, truth):
    results = get_roc_trail(answers, truth)
    n_true = sum(truth.values())
    n_false = len(truth) - n_true
    return calc_roc_from_trail(results, n_true, n_false)


def calc_cat1(answers, truth):
    # (1/n)*(nc+(nu*nc/n))
    n_correct = 0
    n_undecided = 0
    n = len(answers)
    for k, v in answers.items():
        if v == 0.5:
            n_undecided += 1
        else:
            n_correct += (v > 0.5) == truth[k]

    scale = 1.0 / n
    return (n_correct + n_undecided * n_correct * scale) * scale


def print_c(b, c='', prefix='best'):
    print ("%s%8s auc*cat1 %.4f; cat1 %.3f; auc %.3f; range (%d-%d) (%.3f - %.3f)"
           " undecided %d; correct %d tp %d tf %d" % ((c, prefix,) + b) + colour.C_NORMAL)


def split_roc_trail(orig_trail, s, e):
    head = orig_trail[:s]
    middle = orig_trail[s:e]
    target = orig_trail[e]
    score_e = target[0]
    if middle:
        score_s = middle[0][0]
    else:
        score_s = score_e

    tail = orig_trail[e + 1:]
    score, positives, negatives = target
    for _, p, n in middle:
        positives += p
        negatives += n
    return head, [(score, positives, negatives)], tail, score_s, score_e


def search(answers, truth):
    roc_trail = get_roc_trail(answers, truth)
    n_true = sum(truth.values())
    n_false = len(truth) - n_true

    auc = calc_roc_from_trail(roc_trail, n_true, n_false)
    default_cat1 = calc_cat1(answers, truth)
    default_score = auc * default_cat1

    # at bottom end of scale
    true_positives = n_true
    true_negatives = 0
    scale = 1.0 / len(truth)
    candidates = []
    good_candidates = []
    best_cat1 = 0
    best_i = 0
    best_candidate = (0,)

    for i, roc_data in enumerate(roc_trail):
        score, positives, negatives = roc_data
        true_positives -= positives
        n_undecided = positives + negatives
        n_correct = true_positives + true_negatives
        cat1 = (n_correct + n_undecided * n_correct * scale) * scale
        candidate = (cat1 * auc, cat1, auc, i, i, score, score,
                     n_undecided, n_correct, true_positives, true_negatives)
        if candidate > best_candidate:
            best_candidate = candidate
        true_negatives += negatives

    print_c(best_candidate)
    centre_candidate = best_candidate


    centre = best_candidate[3]
    print "searching around"

    index_keys = (0.5, 0.6, 0.67, 0.7)
    indices = {k: 0 for k in index_keys}
    for i, x in enumerate(roc_trail):
        score, u_pos, u_neg = x
        for k, v in indices.items():
            if score <= k:
                indices[k] = i

    print indices
    rindices = {v:k for k, v in indices.items()}

    for s in range(max(centre - 16, 0),
                   min(centre + 16, len(roc_trail))):
        for e in range(s, min(centre + 16, len(roc_trail))):
            head, middle, tail, score_s, score_e = split_roc_trail(roc_trail, s, e)
            auc = calc_roc_from_trail(head + middle + tail, n_true, n_false)
            score, u_pos, u_neg = middle[0]
            n_undecided = u_pos + u_neg
            n_tp = sum(x[1] for x in tail)
            n_tf = sum(x[2] for x in head)
            n_correct = n_tp + n_tf
            cat1 = (n_correct + n_undecided * n_correct * scale) * scale
            candidate = (cat1 * auc, cat1, auc, s, e, score_s, score_e,
                         n_undecided, n_correct, n_tp, n_tf)
            candidates.append(candidate)
            if candidate > best_candidate:
                best_candidate = candidate
                print_c(candidate)
            elif s in rindices and e in rindices:
                if candidate > centre_candidate:
                    c = colour.GREEN
                elif candidate[0] > default_score:
                    c = colour.YELLOW
                else:
                    c = colour.RED
                print_c(candidate, c, prefix='%2s-%2s' % (rindices[s], rindices[e]))





def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-a', '--answer-file', help="read scores from here")
    parser.add_argument('-t', '--truth-file', help="find ground truth here")
    parser.add_argument('-s', '--search', action="store_true",
                        help="search for good c@1 settings.")

    args = parser.parse_args()

    answers = read_answers_file(args.answer_file)
    truth = read_truth_file(args.truth_file)

    auc = calc_auc(answers, truth)
    cat1 = calc_cat1(answers, truth)

    score = auc * cat1
    print "AUC %.3f c@1 %.3f product %.3f" % (auc, cat1, score)

    if args.search:
        search(answers, truth)

main()
